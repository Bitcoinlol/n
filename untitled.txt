I need you to recreate the tabs, buttons, sliders, and dropdown menus from an existing Ul (referred to as the "old UI") in a new UI, using a specified UI library (e.g., [new Ul library name, such as Material-UI, Ant Design, or Tailwind UI]). The goal is to replicate the visual appearance and functionality of these components while extracting and adapting the associated code from the old Ul to the new UI, ensuring that each component works as it did in the old UI. Follow these steps:



Here's the old ui lib -- Services
local ContextActionService = game:GetService('ContextActionService')
local UserInputService = cloneref and cloneref(game:GetService('UserInputService')) or game:GetService('UserInputService')
local ContentProvider = cloneref and cloneref(game:GetService('ContentProvider')) or game:GetService('ContentProvider')
local TweenService = cloneref and cloneref(game:GetService('TweenService')) or game:GetService('TweenService')
local HttpService = cloneref and cloneref(game:GetService('HttpService')) or game:GetService('HttpService')
local TextService = cloneref and cloneref(game:GetService('TextService')) or game:GetService('TextService')
local RunService = cloneref and cloneref(game:GetService('RunService')) or game:GetService('RunService')
local Lighting = cloneref and cloneref(game:GetService('Lighting')) or game:GetService('Lighting')
local Players = cloneref and cloneref(game:GetService('Players')) or game:GetService('Players')
local CoreGui = cloneref and cloneref(game:GetService('CoreGui')) or game:GetService('CoreGui')
local Debris = cloneref and cloneref(game:GetService('Debris')) or game:GetService('Debris')
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService('GuiService')

local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Stats = game:GetService("Stats")

local clientCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local clientHumanoid = clientCharacter:FindFirstChildOfClass("Humanoid")
local AliveGroup = Workspace:FindFirstChild("Alive")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Hotbar = PlayerGui:WaitForChild("Hotbar")
local ParryCD = PlayerGui.Hotbar.Block.UIGradient
local AbilityCD = PlayerGui.Hotbar.Ability.UIGradient

-- Variables
local Phantom = false
local Tornado_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Remote = true
local Parry_Key = nil
local Parry_Arg = nil
local Speed_Divisor_Multiplier = 1.1
local LobbyAP_Speed_Divisor_Multiplier = 1.1
local firstParryFired = false
local ParryThreshold = 2.5
local firstParryType = 'F_Key'
local Previous_Positions = {}
local Parries = 0
local Lerp_Radians = 0
local Last_Warping = tick()
local Previous_Velocity = {}
local Curving = tick()
local Runtime = Workspace.Runtime
local Connections_Manager = {}
local Selected_Parry_Type = "Camera"
local Infinity = false
local Parried = false
local Last_Parry = 0
local AutoParry = true
local Balls = Workspace:WaitForChild('Balls')
local CurrentBall = nil
local InputTask = nil
local Cooldown = 0.02
local RunTime = Workspace:FindFirstChild("Runtime")
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local StrafeSpeed = 36
local Training_Parried = false
local CosmeticsActive = false
local hit_Sound_Enabled = false -- Placeholder, as hit_Sound is not defined
local headLoop = nil

-- Remote detection
task.spawn(function()
    for _, value in pairs(getgc()) do
        if type(value) == "function" and islclosure(value) then
            local protos = debug.getprotos(value)
            local upvalues = debug.getupvalues(value)
            local constants = debug.getconstants(value)
            if #protos == 4 and #upvalues == 24 and #constants >= 102 then
                Parry_Key = debug.getupvalue(value, 17)
                Parry_Remote = debug.getupvalue(value, 18)
                Parry_Arg = debug.getconstant(value, 64)
                break
            end
        end
    end
    if not Parry_Remote then
        warn("[Parry Remote Detection] Failed to find Parry_Remote")
    else
        print("[Parry Remote Detection] Success: Remote =", Parry_Remote and Parry_Remote.Name or "nil", "Key =", Parry_Key, "Arg =", Parry_Arg)
    end
end)

-- Utility functions
local function BlockMovement(actionName, inputState, inputObject)
    return Enum.ContextActionResult.Sink
end

local function updateNavigation(guiObject)
    GuiService.SelectedObject = guiObject
end

local function performFirstPress(parryType)
    if parryType == 'F_Key' then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
    elseif parryType == 'Left_Click' then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    elseif parryType == 'Navigation' then
        local button = Players.LocalPlayer.PlayerGui.Hotbar.Block
        updateNavigation(button)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        task.wait(0.01)
        updateNavigation(nil)
    end
end

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end

function create_animation(object, info, value)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
    animation:Destroy()
    animation = nil
end

-- Animation handling
local Animation = {}
Animation.storage = {}
Animation.current = nil
Animation.track = nil

for _, v in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
    if v:IsA("Animation") and v:GetAttribute("EmoteName") then
        local Emote_Name = v:GetAttribute("EmoteName")
        Animation.storage[Emote_Name] = v
    end
end

local Emotes_Data = {}
for Object in pairs(Animation.storage) do
    table.insert(Emotes_Data, Object)
end
table.sort(Emotes_Data)

-- Auto_Parry system
local Auto_Parry = {}

function Auto_Parry.Parry_Animation()
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local Current_Sword = LocalPlayer.Character:GetAttribute('CurrentlyEquippedSword')

    if not Current_Sword or not Parry_Animation then
        return
    end

    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)

    if not Sword_Data or not Sword_Data['AnimationType'] then
        return
    end

    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            if object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab') then
                local sword_animation_type = object:FindFirstChild('Grab') and 'Grab' or 'GrabParry'
                Parry_Animation = object[sword_animation_type]
            end
        end
    end

    Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
    Grab_Parry:Play()
end

function Auto_Parry.Play_Animation(v)
    local Animations = Animation.storage[v]
    if not Animations then
        return false
    end
    local Animator = LocalPlayer.Character.Humanoid.Animator
    if Animation.track then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    Animation.track:Play()
    Animation.current = v
end

function Auto_Parry.Get_Balls()
    local Balls = {}
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            table.insert(Balls, Instance)
        end
    end
    return Balls
end

function Auto_Parry.Get_Ball()
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            return Instance
        end
    end
end

function Auto_Parry.Lobby_Balls()
    for _, Instance in pairs(Workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end

local Closest_Entity = nil

function Auto_Parry.Closest_Player()
    local Max_Distance = math.huge
    local Found_Entity = nil
    for _, Entity in pairs(Workspace.Alive:GetChildren()) do
        if tostring(Entity) ~= tostring(LocalPlayer) then
            if Entity.PrimaryPart then
                local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position)
                if Distance < Max_Distance then
                    Max_Distance = Distance
                    Found_Entity = Entity
                end
            end
        end
    end
    Closest_Entity = Found_Entity
    return Found_Entity
end

function Auto_Parry:Get_Entity_Properties()
    Auto_Parry.Closest_Player()
    if not Closest_Entity then
        return false
    end
    local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity
    local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit
    local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude
    return {
        Velocity = Entity_Velocity,
        Direction = Entity_Direction,
        Distance = Entity_Distance
    }
end

function Auto_Parry.Parry_Data(Parry_Type)
    Auto_Parry.Closest_Player()
    local Events = {}
    local Camera = Workspace.CurrentCamera
    local Vector2_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector2_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    if isMobile then
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    local Players_Screen_Positions = {}
    for _, v in pairs(Workspace.Alive:GetChildren()) do
        if v ~= LocalPlayer.Character then
            local worldPos = v.PrimaryPart.Position
            local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
            if isOnScreen then
                Players_Screen_Positions[v] = Vector2.new(screenPos.X, screenPos.Y)
            end
            Events[tostring(v)] = screenPos
        end
    end
    if Parry_Type == 'Camera' then
        return {0, Camera.CFrame, Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Backwards' then
        local Backwards_Direction = Camera.CFrame.LookVector * -10000
        Backwards_Direction = Vector3.new(Backwards_Direction.X, 0, Backwards_Direction.Z)
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Backwards_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Straight' then
        local Aimed_Player = nil
        local Closest_Distance = math.huge
        local Mouse_Vector = Vector2.new(Vector2_Mouse_Location[1], Vector2_Mouse_Location[2])
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character then
                local worldPos = v.PrimaryPart.Position
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
                if isOnScreen then
                    local playerScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (Mouse_Vector - playerScreenPos).Magnitude
                    if distance < Closest_Distance then
                        Closest_Distance = distance
                        Aimed_Player = v
                    end
                end
            end
        end
        if Aimed_Player then
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Aimed_Player.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        else
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Closest_Entity and Closest_Entity.PrimaryPart.Position or LocalPlayer.Character.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        end
    elseif Parry_Type == 'Random' then
        return {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-4000, 4000), math.random(-4000, 4000), math.random(-4000, 4000))), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'High' then
        local High_Direction = Camera.CFrame.UpVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + High_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Left' then
        local Left_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - Left_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Right' then
        local Right_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Right_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'RandomTarget' then
        local candidates = {}
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character and v.PrimaryPart then
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
                if isOnScreen then
                    table.insert(candidates, {
                        character = v,
                        screenXY = { screenPos.X, screenPos.Y }
                    })
                end
            end
        end
        if #candidates > 0 then
            local pick = candidates[math.random(1, #candidates)]
            local lookCFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, pick.character.PrimaryPart.Position)
            return {0, lookCFrame, Events, pick.screenXY}
        else
            return {0, Camera.CFrame, Events, { Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2 }}
        end
    end
    return Parry_Type
end

function Auto_Parry.Parry(parryType)
    if not Parry_Remote then
        warn("[Auto_Parry.Parry] Parry_Remote is nil, cannot parry")
        return false
    end

    local Parry_Data = Auto_Parry.Parry_Data(parryType or Selected_Parry_Type)
    if not Parry_Data then
        warn("[Auto_Parry.Parry] Failed to get Parry_Data")
        return false
    end

    local Hash
    if type(Parry_Arg) == "string" and string.match(Parry_Arg, "PARRY_HASH_FAKE") then
        Hash = nil
    else
        Hash = Parry_Arg
    end

    local success, err = pcall(function()
        Parry_Remote:FireServer(Hash, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end)
    if not success then
        warn("[Auto_Parry.Parry] Failed to fire remote:", err)
        return false
    end

    if not firstParryFired then
        performFirstPress(firstParryType)
        firstParryFired = true
    end

    if Parries > 7 then
        return false
    end

    Parries = Parries + 1
    task.delay(0.55, function()
        if Parries > 0 then
            Parries = Parries - 1
        end
    end)

    return true
end

function Auto_Parry.Linear_Interpolation(a, b, time_volume)
    return a + (b - a) * time_volume
end

function Auto_Parry.Is_Curved()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then
        return false
    end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then
        return false
    end
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction = Velocity.Unit
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Speed = Velocity.Magnitude
    local Speed_Threshold = math.min(Speed / 100, 40)
    local Direction_Difference = (Ball_Direction - Velocity).Unit
    local Direction_Similarity = Direction:Dot(Direction_Difference)
    local Dot_Difference = Dot - Direction_Similarity
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Pings = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    local Dot_Threshold = 0.5 - (Pings / 1000)
    local Reach_Time = Distance / Speed - (Pings / 1000)
    local Ball_Distance_Threshold = 15 - math.min(Distance / 1000, 15) + Speed_Threshold
    local Clamped_Dot = math.clamp(Dot, -1, 1)
    local Radians = math.rad(math.asin(Clamped_Dot))
    Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8)
    if Speed > 100 and Reach_Time > Pings / 10 then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15)
    end
    if Distance < Ball_Distance_Threshold then
        return false
    end
    if Dot_Difference < Dot_Threshold then
        return true
    end
    if Lerp_Radians < 0.018 then
        Last_Warping = tick()
    end
    if (tick() - Last_Warping) < (Reach_Time / 1.5) then
        return true
    end
    if (tick() - Curving) < (Reach_Time / 1.5) then
        return true
    end
    return Dot < Dot_Threshold
end

function Auto_Parry:Get_Ball_Properties()
    local Ball = Auto_Parry.Get_Ball()
    local Ball_Velocity = Vector3.zero
    local Ball_Origin = Ball
    local Ball_Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball_Origin.Position).Unit
    local Ball_Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Ball_Dot = Ball_Direction:Dot(Ball_Velocity.Unit)
    return {
        Velocity = Ball_Velocity,
        Direction = Ball_Direction,
        Distance = Ball_Distance,
        Dot = Ball_Dot
    }
end

function Auto_Parry.Spam_Service(self)
    local Ball = Auto_Parry.Get_Ball()
    local Entity = Auto_Parry.Closest_Player()
    if not Ball or not Entity or not Entity.PrimaryPart then
        return false
    end
    local Spam_Accuracy = 0
    local Velocity = Ball.AssemblyLinearVelocity
    local Speed = Velocity.Magnitude
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Velocity.Unit)
    local Target_Position = Entity.PrimaryPart.Position
    local Target_Distance = LocalPlayer:DistanceFromCharacter(Target_Position)
    local Maximum_Spam_Distance = self.Ping + math.min(Speed / 6, 95)
    if self.Entity_Properties.Distance > Maximum_Spam_Distance or self.Ball_Properties.Distance > Maximum_Spam_Distance or Target_Distance > Maximum_Spam_Distance then
        return Spam_Accuracy
    end
    local Maximum_Speed = 5 - math.min(Speed / 5, 5)
    local Maximum_Dot = math.clamp(Dot, -1, 0) * Maximum_Speed
    Spam_Accuracy = Maximum_Spam_Distance - Maximum_Dot
    return Spam_Accuracy
end

local function GetBall()
    for _, Ball in ipairs(Balls:GetChildren()) do
        if Ball:FindFirstChild("ff") then
            return Ball
        end
    end
    return nil
end

local function SpamInput()
    if InputTask then return end
    InputTask = task.spawn(function()
        while AutoParry do
            Auto_Parry.Parry(Selected_Parry_Type)
            task.wait(Cooldown)
        end
        InputTask = nil
    end)
end

local function isCooldownInEffect1(uigradient)
    return uigradient.Offset.Y < 0.4
end

local function isCooldownInEffect2(uigradient)
    return uigradient.Offset.Y == 0.5
end

local function cooldownProtection()
    if isCooldownInEffect1(ParryCD) then
        ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
        return true
    end
    return false
end

local function AutoAbility()
    if isCooldownInEffect2(AbilityCD) then
        if LocalPlayer.Character.Abilities["Raging Deflection"].Enabled or LocalPlayer.Character.Abilities["Rapture"].Enabled or LocalPlayer.Character.Abilities["Calming Deflection"].Enabled or LocalPlayer.Character.Abilities["Aerodynamic Slash"].Enabled or LocalPlayer.Character.Abilities["Fracture"].Enabled or LocalPlayer.Character.Abilities["Death Slash"].Enabled then
            Parried = true
            ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
            task.wait(2.432)
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
            return true
        end
    end
    return false
end

-- UI Initialization with Fatality
local Fatality = loadstring(game:HttpGet("https://raw.githubusercontent.com/Bitcoinlol/Finall/refs/heads/main/niggermobile_final.txt"))()
local Notification = Fatality:CreateNotifier()

Fatality:Loader({
    Name = "Kryp Paid",
    Duration = 4
})

Notification:Notify({
    Title = "Kryp Paid",
    Content = "Hello, "..LocalPlayer.DisplayName.." Welcome back!",
    Icon = "clipboard"
})

local Window = Fatality.new({
    Name = "Kryp Paid",
    Expire = "never",
})

-- Blatant Tab
local Blatant = Window:AddMenu({
    Name = "BLATANT",
    Icon = "sword"
})

-- Player Tab
local Player = Window:AddMenu({
    Name = "PLAYER",
    Icon = "user"
})

-- Auto Parry Section
local AutoParrySection = Blatant:AddSection({
    Position = 'left',
    Name = "AUTO PARRY"
})

AutoParrySection:AddToggle({
    Name = "Auto Parry",
    Callback = function(value)
        if value then
            Connections_Manager['Auto Parry'] = RunService.PreSimulation:Connect(function()
                local One_Ball = Auto_Parry.Get_Ball()
                local Balls = Auto_Parry.Get_Balls()
                for _, Ball in pairs(Balls) do
                    if not Ball then return end
                    local Zoomies = Ball:FindFirstChild('zoomies')
                    if not Zoomies then return end
                    Ball:GetAttributeChangedSignal('target'):Once(function()
                        Parried = false
                    end)
                    if Parried then return end
                    local Ball_Target = Ball:GetAttribute('target')
                    local One_Target = One_Ball:GetAttribute('target')
                    local Velocity = Zoomies.VectorVelocity
                    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 10
                    local Ping_Threshold = math.clamp(Ping / 10, 5, 17)
                    local Speed = Velocity.Magnitude
                    local cappedSpeedDiff = math.min(math.max(Speed - 9.5, 0), 650)
                    local speed_divisor_base = 2.4 + cappedSpeedDiff * 0.002
                    local effectiveMultiplier = Speed_Divisor_Multiplier
                    if getgenv().RandomParryAccuracyEnabled then
                        if Speed < 200 then
                            effectiveMultiplier = 0.7 + (math.random(40, 100) - 1) * (0.35 / 99)
                        else
                            effectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
                        end
                    end
                    local speed_divisor = speed_divisor_base * effectiveMultiplier
                    local Parry_Accuracy = Ping_Threshold + math.max(Speed / speed_divisor, 9.5)
                    local Curved = Auto_Parry.Is_Curved()
                    if Phantom and LocalPlayer.Character:FindFirstChild('ParryHighlight') and getgenv().PhantomV2Detection then
                        ContextActionService:BindAction('BlockPlayerMovement', BlockMovement, false, Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, Enum.UserInputType.Touch)
                        LocalPlayer.Character.Humanoid.WalkSpeed = 36
                        LocalPlayer.Character.Humanoid:MoveTo(Ball.Position)
                        task.spawn(function()
                            repeat
                                if LocalPlayer.Character.Humanoid.WalkSpeed ~= 36 then
                                    LocalPlayer.Character.Humanoid.WalkSpeed = 36
                                end
                                task.wait()
                            until not Phantom
                        end)
                        Ball:GetAttributeChangedSignal('target'):Once(function()
                            ContextActionService:UnbindAction('BlockPlayerMovement')
                            Phantom = false
                            LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
                            LocalPlayer.Character.Humanoid.WalkSpeed = 10
                            task.delay(3, function()
                                LocalPlayer.Character.Humanoid.WalkSpeed = 36
                            end)
                        end)
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy and Phantom then
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                        Parried = true
                    end
                    if Ball:FindFirstChild('AeroDynamicSlashVFX') then
                        Debris:AddItem(Ball.AeroDynamicSlashVFX, 0)
                        Tornado_Time = tick()
                    end
                    if Runtime:FindFirstChild('Tornado') then
                        if (tick() - Tornado_Time) < (Runtime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
                            return
                        end
                    end
                    if One_Target == tostring(LocalPlayer) and Curved then
                        return
                    end
                    if Ball:FindFirstChild("ComboCounter") then
                        return
                    end
                    local Singularity_Cape = LocalPlayer.Character.PrimaryPart:FindFirstChild('SingularityCape')
                    if Singularity_Cape then
                        return
                    end
                    if getgenv().InfinityDetection and Infinity then
                        return
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy then
                        if getgenv().AutoAbility and AutoAbility() then
                            return
                        end
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy then
                        if getgenv().CooldownProtection and cooldownProtection() then
                            return
                        end
                        local Parry_Time = os.clock()
                        local Time_View = Parry_Time - Last_Parry
                        if Time_View > 0.5 then
                            Auto_Parry.Parry_Animation()
                        end
                        if getgenv().AutoParryKeypress then
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
                        else
                            Auto_Parry.Parry(Selected_Parry_Type)
                        end
                        Last_Parry = Parry_Time
                        Parried = true
                    end
                    local Last_Parrys = tick()
                    repeat
                        RunService.PreSimulation:Wait()
                    until (tick() - Last_Parrys) >= 1 or not Parried
                    Parried = false
                end
            end)
        else
            if Connections_Manager['Auto Parry'] then
                Connections_Manager['Auto Parry']:Disconnect()
                Connections_Manager['Auto Parry'] = nil
            end
        end
    end
})

AutoParrySection:AddSlider({
    Name = "Parry Accuracy",
    Default = 100,
    Callback = function(value)
        Speed_Divisor_Multiplier = 0.7 + (value - 1) * (0.35 / 99)
    end
})

local parryTypeMap = {
    ["Camera"] = "Camera",
    ["Random"] = "Random",
    ["Backwards"] = "Backwards",
    ["Straight"] = "Straight",
    ["High"] = "High",
    ["Left"] = "Left",
    ["Right"] = "Right",
    ["Random Target"] = "RandomTarget"
}

AutoParrySection:AddDropdown({
    Name = "Curve Type",
    Values = {"Camera", "Random", "Backwards", "Straight", "High", "Left", "Right", "Random Target"},
    Default = "Camera",
    Callback = function(value)
        Selected_Parry_Type = parryTypeMap[value] or value
    end
})

AutoParrySection:AddToggle({
    Name = "Random Parry Accuracy",
    Callback = function(value)
        getgenv().RandomParryAccuracyEnabled = value
    end
})

AutoParrySection:AddToggle({
    Name = "Infinity Detection",
    Callback = function(value)
        getgenv().InfinityDetection = value
    end
})

AutoParrySection:AddToggle({
    Name = "Keypress",
    Callback = function(value)
        getgenv().AutoParryKeypress = value
    end
})

AutoParrySection:AddToggle({
    Name = "Phantom Detection",
    Callback = function(value)
        getgenv().PhantomV2Detection = value
    end
})

-- Auto Spam Parry Section
local AutoSpamParrySection = Blatant:AddSection({
    Position = 'right',
    Name = "AUTO SPAM PARRY"
})

AutoSpamParrySection:AddToggle({
    Name = "Auto Spam Parry",
    Callback = function(value)
        if value then
            Connections_Manager['Auto Spam'] = RunService.PreSimulation:Connect(function()
                local Ball = Auto_Parry.Get_Ball()
                if not Ball then return end
                local Zoomies = Ball:FindFirstChild('zoomies')
                if not Zoomies then return end
                Auto_Parry.Closest_Player()
                local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
                local Ping_Threshold = math.clamp(Ping / 10, 1, 16)
                local Ball_Target = Ball:GetAttribute('target')
                local Ball_Properties = Auto_Parry:Get_Ball_Properties()
                local Entity_Properties = Auto_Parry:Get_Entity_Properties()
                local Spam_Accuracy = Auto_Parry.Spam_Service({
                    Ball_Properties = Ball_Properties,
                    Entity_Properties = Entity_Properties,
                    Ping = Ping_Threshold
                })
                local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
                local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
                local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
                local Ball_Direction = Zoomies.VectorVelocity.Unit
                local Dot = Direction:Dot(Ball_Direction)
                local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
                if not Ball_Target then return end
                if Target_Distance > Spam_Accuracy or Distance > Spam_Accuracy then return end
                local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')
                if Pulsed then return end
                if Ball_Target == tostring(LocalPlayer) and Target_Distance > 30 and Distance > 30 then
                    return
                end
                local threshold = ParryThreshold
                if Distance <= Spam_Accuracy and Parries > threshold then
                    if getgenv().SpamParryKeypress then
                        VirtualInputManager:SendKeyEvent(true, nil, false, game)
                    else
                        Auto_Parry.Parry(Selected_Parry_Type)
                    end
                end
            end)
        else
            if Connections_Manager['Auto Spam'] then
                Connections_Manager['Auto Spam']:Disconnect()
                Connections_Manager['Auto Spam'] = nil
            end
        end
    end
})

AutoSpamParrySection:AddDropdown({
    Name = "Parry Type",
    Values = {"Legit", "Blatant"},
    Default = "Legit",
    Callback = function(value) end
})

AutoSpamParrySection:AddSlider({
    Name = "Parry Threshold",
    Default = 2.5,
    Callback = function(value)
        ParryThreshold = value
    end
})

if not isMobile then
    AutoSpamParrySection:AddToggle({
        Name = "Animation Fix",
        Callback = function(value)
            if value then
                Connections_Manager['Animation Fix'] = RunService.PreSimulation:Connect(function()
                    local Ball = Auto_Parry.Get_Ball()
                    if not Ball then return end
                    local Zoomies = Ball:FindFirstChild('zoomies')
                    if not Zoomies then return end
                    Auto_Parry.Closest_Player()
                    local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
                    local Ping_Threshold = math.clamp(Ping / 10, 10, 16)
                    local Ball_Target = Ball:GetAttribute('target')
                    local Ball_Properties = Auto_Parry:Get_Ball_Properties()
                    local Entity_Properties = Auto_Parry:Get_Entity_Properties()
                    local Spam_Accuracy = Auto_Parry.Spam_Service({
                        Ball_Properties = Ball_Properties,
                        Entity_Properties = Entity_Properties,
                        Ping = Ping_Threshold
                    })
                    local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
                    local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
                    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
                    local Ball_Direction = Zoomies.VectorVelocity.Unit
                    local Dot = Direction:Dot(Ball_Direction)
                    local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
                    if not Ball_Target then return end
                    if Target_Distance > Spam_Accuracy or Distance > Spam_Accuracy then return end
                    local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')
                    if Pulsed then return end
                    if Ball_Target == tostring(LocalPlayer) and Target_Distance > 30 and Distance > 30 then
                        return
                    end
                    local threshold = ParryThreshold
                    if Distance <= Spam_Accuracy and Parries > threshold then
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                    end
                end)
            else
                if Connections_Manager['Animation Fix'] then
                    Connections_Manager['Animation Fix']:Disconnect()
                    Connections_Manager['Animation Fix'] = nil
                end
            end
        end
    })
end

-- Manual Spam Section
local ManualSpamSection = Blatant:AddSection({
    Position = 'left',
    Name = "MANUAL SPAM"
})

local AutoManualSpamEnabled = false
local ManualSpamActive = false

-- Function to toggle manual spam (used by both UI and toggle)
local function toggleManualSpam(activate)
    ManualSpamActive = activate
    local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
    if button then
        if AutoManualSpamEnabled and not ManualSpamActive then
            button.Text = "Auto"
            button.TextColor3 = Color3.new(0, 0, 1) -- Blue for Auto
        else
            button.Text = activate and "Stop" or "Clash Mode"
            button.TextColor3 = activate and Color3.new(0, 1, 0) or Color3.new(1, 0, 0) -- Green for Stop, Red for Clash Mode
        end
    end
    if activate then
        if not Connections_Manager['Manual Spam'] then
            Connections_Manager['Manual Spam'] = RunService.Heartbeat:Connect(function()
                Auto_Parry.Parry(Selected_Parry_Type)
            end)
        end
    else
        if Connections_Manager['Manual Spam'] then
            Connections_Manager['Manual Spam']:Disconnect()
            Connections_Manager['Manual Spam'] = nil
        end
    end
end

-- Auto Manual Spam Logic with Faster Detection
local function checkAutoManualSpam()
    if not AutoManualSpamEnabled then return end
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then
        if ManualSpamActive then
            toggleManualSpam(false)
        end
        return
    end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then
        if ManualSpamActive then
            toggleManualSpam(false)
        end
        return
    end
    Auto_Parry.Closest_Player()
    local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    local Ping_Threshold = math.clamp(Ping / 10, 1, 16)
    local Ball_Target = Ball:GetAttribute('target')
    local Ball_Properties = Auto_Parry:Get_Ball_Properties()
    local Entity_Properties = Auto_Parry:Get_Entity_Properties()
    local Spam_Accuracy = Auto_Parry.Spam_Service({
        Ball_Properties = Ball_Properties,
        Entity_Properties = Entity_Properties,
        Ping = Ping_Threshold
    })
    local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
    local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Ball_Direction = Zoomies.VectorVelocity.Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
    local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')

    -- Optimized conditions for faster detection
    local FastSpamAccuracy = Spam_Accuracy * 0.8 -- 20% tighter threshold for faster reaction
    if Ball_Target and not Pulsed and Target_Distance <= FastSpamAccuracy and Distance <= FastSpamAccuracy and Parries <= ParryThreshold then
        if not ManualSpamActive then
            toggleManualSpam(true)
        end
    else
        if ManualSpamActive then
            toggleManualSpam(false)
        end
    end
end

-- Toggle Automatically Button
ManualSpamSection:AddButton({
    Name = "Toggle Automatically",
    Callback = function()
        AutoManualSpamEnabled = not AutoManualSpamEnabled
        if AutoManualSpamEnabled then
            Connections_Manager['Auto Manual Spam'] = RunService.Heartbeat:Connect(checkAutoManualSpam)
            local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
            if button and not ManualSpamActive then
                button.Text = "Auto"
                button.TextColor3 = Color3.new(0, 0, 1) -- Blue for Auto
            end
        else
            if Connections_Manager['Auto Manual Spam'] then
                Connections_Manager['Auto Manual Spam']:Disconnect()
                Connections_Manager['Auto Manual Spam'] = nil
            end
            if ManualSpamActive then
                toggleManualSpam(false)
            end
            local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
            if button then
                button.Text = "Clash Mode"
                button.TextColor3 = Color3.new(1, 0, 0) -- Red for Clash Mode
            end
        end
    end
})

-- Manual Spam UI for Both Mobile and PC
ManualSpamSection:AddToggle({
    Name = "Manual Spam UI",
    Callback = function(value)
        getgenv().spamui = value
        if value then
            -- Create UI if it doesn't exist
            if not CoreGui:FindFirstChild("ManualSpamUI") then
                local gui = Instance.new("ScreenGui")
                gui.Name = "ManualSpamUI"
                gui.ResetOnSpawn = false
                gui.Parent = CoreGui

                local frame = Instance.new("Frame")
                frame.Name = "MainFrame"
                frame.Position = UDim2.new(0, 20, 0, 20)
                frame.Size = UDim2.new(0, 160, 0, 60)
                frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                frame.BackgroundTransparency = 0.3
                frame.BorderSizePixel = 0
                frame.Active = true
                frame.Draggable = true
                frame.Parent = gui

                local uiCorner = Instance.new("UICorner")
                uiCorner.CornerRadius = UDim.new(0, 12)
                uiCorner.Parent = frame

                local uiStroke = Instance.new("UIStroke")
                uiStroke.Thickness = 2
                uiStroke.Color = Color3.new(0, 0, 0)
                uiStroke.Parent = frame

                local button = Instance.new("TextButton")
                button.Name = "ClashModeButton"
                button.Text = AutoManualSpamEnabled and "Auto" or "Clash Mode"
                button.TextColor3 = AutoManualSpamEnabled and Color3.new(0, 0, 1) or Color3.new(1, 0, 0)
                button.Size = UDim2.new(0, 120, 0, 40)
                button.Position = UDim2.new(0.5, -60, 0.5, -20)
                button.BackgroundTransparency = 1
                button.BorderSizePixel = 0
                button.Font = Enum.Font.GothamSemibold
                button.TextSize = 18
                button.Parent = frame

                button.MouseButton1Click:Connect(function()
                    if not AutoManualSpamEnabled then
                        toggleManualSpam(not ManualSpamActive)
                    end
                end)
            end
        else
            -- Clean up UI and connections
            if CoreGui:FindFirstChild("ManualSpamUI") then
                CoreGui:FindFirstChild("ManualSpamUI"):Destroy()
            end
            if Connections_Manager['Manual Spam'] then
                Connections_Manager['Manual Spam']:Disconnect()
                Connections_Manager['Manual Spam'] = nil
            end
            if Connections_Manager['Auto Manual Spam'] then
                Connections_Manager['Auto Manual Spam']:Disconnect()
                Connections_Manager['Auto Manual Spam'] = nil
            end
            ManualSpamActive = false
            AutoManualSpamEnabled = false
        end
    end
})

-- Lobby Auto Parry Section
local LobbyAPSection = Blatant:AddSection({
    Position = 'right',
    Name = "LOBBY AP"
})

LobbyAPSection:AddToggle({
    Name = "Lobby Auto Parry",
    Callback = function(value)
        if value then
            Connections_Manager['Lobby AP'] = RunService.Heartbeat:Connect(function()
                local Ball = Auto_Parry.Lobby_Balls()
                if not Ball then return end
                local Zoomies = Ball:FindFirstChild('zoomies')
                if not Zoomies then return end
                Ball:GetAttributeChangedSignal('target'):Once(function()
                    Training_Parried = false
                end)
                if Training_Parried then return end
                local Ball_Target = Ball:GetAttribute('target')
                local Velocity = Zoomies.VectorVelocity
                local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
                local Speed = Velocity.Magnitude
                local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 10
                local LobbyAPcappedSpeedDiff = math.min(math.max(Speed - 9.5, 0), 650)
                local LobbyAPspeed_divisor_base = 2.4 + LobbyAPcappedSpeedDiff * 0.002
                local LobbyAPeffectiveMultiplier = LobbyAP_Speed_Divisor_Multiplier
                if getgenv().LobbyAPRandomParryAccuracyEnabled then
                    LobbyAPeffectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
                end
                local LobbyAPspeed_divisor = LobbyAPspeed_divisor_base * LobbyAPeffectiveMultiplier
                local LobbyAPParry_Accuracys = Ping + math.max(Speed / LobbyAPspeed_divisor, 9.5)
                if Ball_Target == tostring(LocalPlayer) and Distance <= LobbyAPParry_Accuracys then
                    if getgenv().LobbyAPKeypress then
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                    else
                        Auto_Parry.Parry(Selected_Parry_Type)
                    end
                    Training_Parried = true
                end
                local Last_Parrys = tick()
                repeat
                    RunService.PreSimulation:Wait()
                until (tick() - Last_Parrys) >= 1 or not Training_Parried
                Training_Parried = false
            end)
        else
            if Connections_Manager['Lobby AP'] then
                Connections_Manager['Lobby AP']:Disconnect()
                Connections_Manager['Lobby AP'] = nil
            end
        end
    end
})

LobbyAPSection:AddSlider({
    Name = "Parry Accuracy",
    Default = 100,
    Callback = function(value)
        LobbyAP_Speed_Divisor_Multiplier = 0.7 + (value - 1) * (0.35 / 99)
    end
})

LobbyAPSection:AddToggle({
    Name = "Random Parry Accuracy",
    Callback = function(value)
        getgenv().LobbyAPRandomParryAccuracyEnabled = value
    end
})

-- Speed Section (Player Tab)
local SpeedSection = Player:AddSection({
    Position = 'left',
    Name = "SPEED"
})

SpeedSection:AddToggle({
    Name = "Speed",
    Callback = function(value)
        if value then
            Connections_Manager['Strafe'] = RunService.PreSimulation:Connect(function()
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("Humanoid") then
                    character.Humanoid.WalkSpeed = StrafeSpeed
                end
            end)
        else
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.WalkSpeed = 36
            end
            if Connections_Manager['Strafe'] then
                Connections_Manager['Strafe']:Disconnect()
                Connections_Manager['Strafe'] = nil
            end
        end
    end
})

SpeedSection:AddSlider({
    Name = "Speed",
    Min = 36,
    Max = 200,
    Default = 36,
    Callback = function(value)
        StrafeSpeed = value
    end
})

-- Spinbot Section
local SpinbotSection = Player:AddSection({
    Position = 'right',
    Name = "SPINBOT"
})

SpinbotSection:AddToggle({
    Name = "Spinbot",
    Callback = function(value)
        getgenv().Spinbot = value
        if value then
            getgenv().spin = true
            getgenv().spinSpeed = getgenv().spinSpeed or 1
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Client = Players.LocalPlayer
            local function spinCharacter()
                while getgenv().spin do
                    RunService.Heartbeat:Wait()
                    local char = Client.Character
                    local funcHRP = char and char:FindFirstChild("HumanoidRootPart")
                    if char and funcHRP then
                        funcHRP.CFrame *= CFrame.Angles(0, getgenv().spinSpeed, 0)
                    end
                end
            end
            if not getgenv().spinThread then
                getgenv().spinThread = coroutine.create(spinCharacter)
                coroutine.resume(getgenv().spinThread)
            end
        else
            getgenv().spin = false
            if getgenv().spinThread then
                getgenv().spinThread = nil
            end
        end
    end
})

SpinbotSection:AddSlider({
    Name = "Speed",
    Min = 1,
    Max = 100,
    Default = 1,
    Callback = function(value)
        getgenv().spinSpeed = math.rad(value)
    end
})

-- Field of View Section
local FieldOfViewSection = Player:AddSection({
    Position = 'left',
    Name = "FIELD OF VIEW"
})

FieldOfViewSection:AddToggle({
    Name = "Field of View",
    Callback = function(value)
        getgenv().CameraEnabled = value
        local Camera = Workspace.CurrentCamera
        if value then
            getgenv().CameraFOV = getgenv().CameraFOV or 70
            Camera.FieldOfView = getgenv().CameraFOV
            if not getgenv().FOVLoop then
                getgenv().FOVLoop = RunService.RenderStepped:Connect(function()
                    if getgenv().CameraEnabled then
                        Camera.FieldOfView = getgenv().CameraFOV
                    end
                end)
            end
        else
            Camera.FieldOfView = 70
            if getgenv().FOVLoop then
                getgenv().FOVLoop:Disconnect()
                getgenv().FOVLoop = nil
            end
        end
    end
})

FieldOfViewSection:AddSlider({
    Name = "FOV",
    Min = 50,
    Max = 150,
    Default = 70,
    Callback = function(value)
        getgenv().CameraFOV = value
        if getgenv().CameraEnabled then
            Workspace.CurrentCamera.FieldOfView = value
        end
    end
})

-- Player Cosmetics Section
local PlayerCosmeticsSection = Player:AddSection({
    Position = 'right',
    Name = "PLAYER COSMETICS"
})

_G.PlayerCosmeticsCleanup = {}

PlayerCosmeticsSection:AddToggle({
    Name = "Korblox/Headless",
    Callback = function(value)
        local players = game:GetService("Players")
        local lp = players.LocalPlayer
        local function applyKorblox(character)
            local rightLeg = character:FindFirstChild("RightLeg") or character:FindFirstChild("Right Leg")
            if not rightLeg then
                warn("Right leg not found on character")
                return
            end
            for _, child in pairs(rightLeg:GetChildren()) do
                if child:IsA("SpecialMesh") then
                    child:Destroy()
                end
            end
            local specialMesh = Instance.new("SpecialMesh")
            specialMesh.MeshId = "rbxassetid://101851696"
            specialMesh.TextureId = "rbxassetid://115727863"
            specialMesh.Scale = Vector3.new(1, 1, 1)
            specialMesh.Parent = rightLeg
        end
        local function saveRightLegProperties(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg then
                    local originalMesh = rightLeg:FindFirstChildOfClass("SpecialMesh")
                    if originalMesh then
                        _G.PlayerCosmeticsCleanup.originalMeshId = originalMesh.MeshId
                        _G.PlayerCosmeticsCleanup.originalTextureId = originalMesh.TextureId
                        _G.PlayerCosmeticsCleanup.originalScale = originalMesh.Scale
                    else
                        _G.PlayerCosmeticsCleanup.hadNoMesh = true
                    end
                    _G.PlayerCosmeticsCleanup.rightLegChildren = {}
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            table.insert(_G.PlayerCosmeticsCleanup.rightLegChildren, {
                                ClassName = child.ClassName,
                                Properties = {
                                    MeshId = child.MeshId,
                                    TextureId = child.TextureId,
                                    Scale = child.Scale
                                }
                            })
                        end
                    end
                end
            end
        end
        local function restoreRightLeg(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg and _G.PlayerCosmeticsCleanup.rightLegChildren then
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            child:Destroy()
                        end
                    end
                    if _G.PlayerCosmeticsCleanup.hadNoMesh then
                        return
                    end
                    for _, childData in ipairs(_G.PlayerCosmeticsCleanup.rightLegChildren) do
                        if childData.ClassName == "SpecialMesh" then
                            local newMesh = Instance.new("SpecialMesh")
                            newMesh.MeshId = childData.Properties.MeshId
                            newMesh.TextureId = childData.Properties.TextureId
                            newMesh.Scale = childData.Properties.Scale
                            newMesh.Parent = rightLeg
                        end
                    end
                end
            end
        end
        if value then
            CosmeticsActive = true
            getgenv().Config = {
                Headless = true
            }
            if lp.Character then
                local head = lp.Character:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(lp.Character)
                applyKorblox(lp.Character)
            end
            _G.PlayerCosmeticsCleanup.characterAddedConn = lp.CharacterAdded:Connect(function(char)
                local head = char:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(char)
                applyKorblox(char)
            end)
            if getgenv().Config.Headless then
                headLoop = task.spawn(function()
                    while CosmeticsActive do
                        local char = lp.Character
                        if char then
                            local head = char:FindFirstChild("Head")
                            if head then
                                head.Transparency = 1
                                local decal = head:FindFirstChildOfClass("Decal")
                                if decal then
                                    decal:Destroy()
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        else
            CosmeticsActive = false
            if _G.PlayerCosmeticsCleanup.characterAddedConn then
                _G.PlayerCosmeticsCleanup.characterAddedConn:Disconnect()
                _G.PlayerCosmeticsCleanup.characterAddedConn = nil
            end
            if headLoop then
                task.cancel(headLoop)
                headLoop = nil
            end
            local char = lp.Character
            if char then
                local head = char:FindFirstChild("Head")
                if head and _G.PlayerCosmeticsCleanup.headTransparency then
                    head.Transparency = _G.PlayerCosmeticsCleanup.headTransparency
                    if _G.PlayerCosmeticsCleanup.faceDecalId then
                        local newDecal = head:FindFirstChildOfClass("Decal") or Instance.new("Decal", head)
                        newDecal.Name = _G.PlayerCosmeticsCleanup.faceDecalName or "face"
                        newDecal.Texture = _G.PlayerCosmeticsCleanup.faceDecalId
                        newDecal.Face = Enum.NormalId.Front
                    end
                end
                restoreRightLeg(char)
            end
            _G.PlayerCosmeticsCleanup = {}
        end
    end
})

-- Connections and Events
ReplicatedStorage.Remotes.InfinityBall.OnClientEvent:Connect(function(a, b)
    Infinity = b
end)

Balls.ChildAdded:Connect(function(Value)
    Value.ChildAdded:Connect(function(Child)
        if getgenv().SlashOfFuryDetection and Child.Name == 'ComboCounter' then
            local Sof_Label = Child:FindFirstChildOfClass('TextLabel')
            if Sof_Label then
                repeat
                    local Slashes_Counter = tonumber(Sof_Label.Text)
                    if Slashes_Counter and Slashes_Counter < 32 then
                        Auto_Parry.Parry(Selected_Parry_Type)
                    end
                    task.wait()
                until not Sof_Label.Parent or not Sof_Label
            end
        end
    end)
end)

RunTime.ChildAdded:Connect(function(Object)
    local Name = Object.Name
    if getgenv().PhantomV2Detection then
        if Name == "maxTransmission" or Name == "transmissionpart" then
            local Weld = Object:FindFirstChildWhichIsA("WeldConstraint")
            if Weld then
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                if Character and Weld.Part1 == Character.HumanoidRootPart then
                    CurrentBall = GetBall()
                    Weld:Destroy()
                    if CurrentBall then
                        local FocusConnection
                        FocusConnection = RunService.RenderStepped:Connect(function()
                            local Highlighted = CurrentBall:GetAttribute("highlighted")
                            if Highlighted == true then
                                LocalPlayer.Character.Humanoid.WalkSpeed = 36
                                local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
                                if HumanoidRootPart then
                                    local PlayerPosition = HumanoidRootPart.Position
                                    local BallPosition = CurrentBall.Position
                                    local PlayerToBall = (BallPosition - PlayerPosition).Unit
                                    LocalPlayer.Character.Humanoid:Move(PlayerToBall, false)
                                end
                            elseif Highlighted == false then
                                FocusConnection:Disconnect()
                                LocalPlayer.Character.Humanoid.WalkSpeed = 10
                                LocalPlayer.Character.Humanoid:Move(Vector3.new(0, 0, 0), false)
                                task.delay(3, function()
                                    LocalPlayer.Character.Humanoid.WalkSpeed = 36
                                end)
                                CurrentBall = nil
                            end
                        end)
                        task.delay(3, function()
                            if FocusConnection and FocusConnection.Connected then
                                FocusConnection:Disconnect()
                                LocalPlayer.Character.Humanoid:Move(Vector3.new(0, 0, 0), false)
                                LocalPlayer.Character.Humanoid.WalkSpeed = 36
                                CurrentBall = nil
                            end
                        end)
                    end
                end
            end
        end
    end
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if hit_Sound_Enabled then
        -- hit_Sound:Play() -- Placeholder, as hit_Sound is not defined
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    if root.Parent and root.Parent ~= LocalPlayer.Character then
        if root.Parent.Parent ~= Workspace.Alive then
            return
        end
    end
    Auto_Parry.Closest_Player()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then return end
    local Target_Distance = Closest_Entity and (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude or math.huge
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball.AssemblyLinearVelocity.Unit)
    local Curve_Detected = Auto_Parry.Is_Curved()
    if Target_Distance < 15 and Distance < 15 and Dot > -0.25 then
        if Curve_Detected then
            Auto_Parry.Parry(Selected_Parry_Type)
        end
    end
    if not Grab_Parry then return end
    Grab_Parry:Stop()
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character.Parent ~= Workspace.Alive then
        return
    end
    if not Grab_Parry then return end
    Grab_Parry:Stop()
end)

Workspace.Balls.ChildAdded:Connect(function()
    Parried = false
end)

Workspace.Balls.ChildRemoved:Connect(function(Value)
    Parries = 0
    Parried = false
    if Connections_Manager['Target Change'] then
        Connections_Manager['Target Change']:Disconnect()
        Connections_Manager['Target Change'] = nil
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(a, b)
    local Primary_Part = LocalPlayer.Character.PrimaryPart
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then return end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then return end
    local Speed = Zoomies.VectorVelocity.Magnitude
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction = Velocity.Unit
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Pings = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    local Speed_Threshold = math.min(Speed / 100, 40)
    local Reach_Time = Distance / Speed - (Pings / 1000)
    local Enough_Speed = Speed > 100
    local Ball_Distance_Threshold = 15 - math.min(Distance / 1000, 15) + Speed_Threshold
    if Enough_Speed and Reach_Time > Pings / 10 then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15)
    end
    if b ~= Primary_Part and Distance > Ball_Distance_Threshold then
        Curving = tick()
    end
end)

ReplicatedStorage.Remotes.Phantom.OnClientEvent:Connect(function(a, b)
    if b.Name == tostring(LocalPlayer) then
        Phantom = true
    else
        Phantom = false
    end
end)

Workspace.Balls.ChildRemoved:Connect(function()
    Phantom = false
end)


Here's the new one local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/MarchHubOnTopFr/Allusive-UI/refs/heads/main/Source.lua"))()
local main = Library.new()

-- Tabs
local combat_tab = main:create_tab("Combat", "rbxassetid://76499042599127")
local utility_tab = main:create_tab("Utility", "rbxassetid://126017907477623")

-- Combat Module
local aimbot = combat_tab:create_module({
  title = "Aimbot",
  flag = "Aimbot",
  description = "Locks onto enemies",
  section = "left",
  callback = function(value)
    print("Aimbot enabled:", value)
    Library.SendNotification({title = "Aimbot", text = value and "Enabled!" or "Disabled!", duration = 3})
  end
})

aimbot:create_dropdown({
  title = "Target Part",
  flag = "Target_Part",
  options = {"Head", "Torso", "Random"},
  multi_dropdown = false,
  maximum_options = 1,
  callback = function(value) print("Targeting:", value) end
})

aimbot:create_slider({
  title = "Aimbot Sensitivity",
  flag = "Aimbot_Sensitivity",
  maximum_value = 100,
  minimum_value = 10,
  value = 50,
  round_number = true,
  callback = function(value) print("Sensitivity:", value) end
})

aimbot:create_checkbox({
  title = "Silent Aim",
  flag = "Silent_Aim",
  callback = function(value) print("Silent Aim:", value) end
})

-- Utility Module
local speedhack = utility_tab:create_module({
  title = "Speed Hack",
  flag = "Speed_Hack",
  description = "Increases player speed",
  section = "right",
  callback = function(value) print("Speed Hack:", value) end
})

speedhack:create_paragraph({
  title = "Info",
  text = "Use responsibly to avoid detection."
})

speedhack:create_textbox({
  title = "Speed Value",
  placeholder = "Enter speed...",
  flag = "Speed_Value",
  callback = function(text) print("Speed set to:", text) end
})

main:load()




you cant use the code from the old ui you have to follow the example on how to make buttons sliders from the new ui heres the example code on the new ui local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/MarchHubOnTopFr/Allusive-UI/refs/heads/main/Source.lua"))()
local main = Library.new()

-- Tabs
local combat_tab = main:create_tab("Combat", "rbxassetid://76499042599127")
local utility_tab = main:create_tab("Utility", "rbxassetid://126017907477623")

-- Combat Module
local aimbot = combat_tab:create_module({
  title = "Aimbot",
  flag = "Aimbot",
  description = "Locks onto enemies",
  section = "left",
  callback = function(value)
    print("Aimbot enabled:", value)
    Library.SendNotification({title = "Aimbot", text = value and "Enabled!" or "Disabled!", duration = 3})
  end
})

aimbot:create_dropdown({
  title = "Target Part",
  flag = "Target_Part",
  options = {"Head", "Torso", "Random"},
  multi_dropdown = false,
  maximum_options = 1,
  callback = function(value) print("Targeting:", value) end
})

aimbot:create_slider({
  title = "Aimbot Sensitivity",
  flag = "Aimbot_Sensitivity",
  maximum_value = 100,
  minimum_value = 10,
  value = 50,
  round_number = true,
  callback = function(value) print("Sensitivity:", value) end
})

aimbot:create_checkbox({
  title = "Silent Aim",
  flag = "Silent_Aim",
  callback = function(value) print("Silent Aim:", value) end
})

-- Utility Module
local speedhack = utility_tab:create_module({
  title = "Speed Hack",
  flag = "Speed_Hack",
  description = "Increases player speed",
  section = "right",
  callback = function(value) print("Speed Hack:", value) end
})

speedhack:create_paragraph({
  title = "Info",
  text = "Use responsibly to avoid detection."
})

speedhack:create_textbox({
  title = "Speed Value",
  placeholder = "Enter speed...",
  flag = "Speed_Value",
  callback = function(text) print("Speed set to:", text) end
})


all you have to do is recreate the tabsand buttons in the tabs from the old ui using the example on the new ui on how to create buttons sliders and drop down menus  and then you have to extract the code from the buttons from the old ui so that when the buttons sliders or drop down menus are toggled on on the new ui they work 